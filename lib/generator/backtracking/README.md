# BacktrackingGridBuilder Design Document

**Note: This is the default grid generation algorithm for the WordClock project.**

## Problem Statement

Build a Qlocktwo-style word clock grid that displays times by lighting up consecutive letters to form words. The grid must be compact (11x10) and efficiently represent all possible time phrases.

## Grid Constraints

### Hard Constraints (Must Satisfy)
1. **Grid Dimensions**: 11 columns × 10 rows (110 cells total)
2. **Word Consecutiveness**: Each word must be made of consecutive letters (horizontal, left-to-right)
3. **Word Order**: Words in a phrase must appear in reading order (row-major: left-to-right, top-to-bottom)
4. **Word Separation**: Between lit-up words in the same phrase:
   - Must have at least one cell of separation (if `requiresPadding=true`)
   - Separation can be: padding characters, other words from different phrases, or newline (different row)
   - If on same row: at least 1 cell gap
   - If on different rows: no gap needed (newline acts as separator)
5. **No Conflicts**: A cell can only contain one character
6. **Character Matching**: When words overlap, characters must match exactly

### Soft Constraints (Optimization Goals)
1. **Compactness**: Minimize empty/padding cells
2. **Overlap Maximization**: Reuse cells between words when possible
3. **Reading Flow**: Prefer top-left to bottom-right diagonal placement
4. **Density**: Keep words close together while respecting separation rules

## Data Structures

### 1. Word-Level Dependency Graph
Unlike the character-level DAG used in the greedy algorithm, this approach uses a **word-level DAG**. Each node represents a unique word (or a specific instance of a word if it appears multiple times in a phrase). Edges represent the required reading order within each time phrase. This graph allows the algorithm to understand which words must appear before others across all possible time displays.

### 2. Grid State
The grid state tracks the 2D array of characters, the current list of word placements, and which phrases are currently satisfied. It also maintains metrics like compactness (overlap ratio) and density to guide the search toward optimal solutions.

## Algorithm: Backtracking with Pruning

The algorithm uses a depth-first backtracking search to find a valid and optimal grid layout.

### Phase 1: Graph Construction
The algorithm first tokenizes all possible time phrases for a language and builds the word-level dependency graph. It computes metadata such as word frequency and average position to help prioritize placement.

### Phase 2: Word Prioritization
Words are sorted by a priority score based on their frequency, length, and position. High-frequency and longer words are placed earlier in the search because they are harder to fit and have the most impact on the final grid structure.

### Phase 3: Backtracking Search
The core search function recursively attempts to place the next word from the priority list. For each word, it generates candidate positions, scores them, and tries them in order. If a path leads to an impossible state, it backtracks and tries the next candidate.

### Phase 4: Candidate Generation & Scoring
Candidates are generated by scanning the grid for positions where the word fits without character conflicts. The algorithm explicitly looks for opportunities to overlap with existing words. Positions are scored based on:
- **Overlap Bonus**: High reward for reusing existing characters.
- **Compactness**: Preference for positions near existing words.
- **Reading Flow**: Preference for top-left to bottom-right placement.
- **Wasted Space**: Penalties for creating unreachable gaps.

### Phase 5: Constraint & Pruning
At each step, the algorithm validates that the new placement doesn't violate phrase ordering or separation rules. It also uses pruning heuristics to abandon search paths that:
- Exceed the grid capacity.
- Make it impossible to satisfy remaining phrases.
- Fall below a minimum compactness threshold.

## Implementation Details

### Shared Validation
The algorithm leverages shared validation logic in [lib/generator/utils/grid_validator.dart](lib/generator/utils/grid_validator.dart). This ensures that both the greedy and backtracking algorithms adhere to the same rules for word order, separation, and padding.

### Word Dependency Graph
The [lib/generator/backtracking/dependency_graph.dart](lib/generator/backtracking/dependency_graph.dart) component builds a word-level graph from the target language. It identifies unique words, tracks which phrases they belong to, and computes priorities based on frequency and length.

### Grid State Management
The [lib/generator/backtracking/grid_state.dart](lib/generator/backtracking/grid_state.dart) component manages the 2D grid during the search. It tracks word placements, character overlaps, and phrase satisfaction, providing the necessary state for the backtracking algorithm to make decisions.

### Core Search Logic
The [lib/generator/backtracking/grid_builder.dart](lib/generator/backtracking/grid_builder.dart) file contains the main backtracking search. It coordinates candidate generation, scoring, and pruning to find an optimal grid layout within the specified constraints.

## Key Advantages Over ConstraintGridBuilder

1. **Exhaustive Search**: Backtracking explores more possibilities
2. **Better Overlap**: Explicitly tries overlap positions
3. **Phrase-Aware**: Directly models phrase constraints in graph
4. **Pruning**: Eliminates bad paths early
5. **Word-Level**: Works with words (not characters), more natural for this problem

## Design Decisions

1. **Iterative Deepening**: Not needed - we want ALL words placed, so increasing depth gradually doesn't help. We use pruning instead.

2. **Timeout**: 30-60 seconds is reasonable (configurable via `maxSearchTimeSeconds`)

3. **Vertical Words**: Not currently supported - Qlocktwo clocks use horizontal words only

4. **Multiple Solutions**: Return best N solutions ranked by compactness/density (TODO: implement solution ranking)

## Usage

### Command Line
```bash
# Use backtracking algorithm in grid_builder
dart run bin/grid_builder.dart --algorithm backtracking -l EN

# See all options
dart run bin/grid_builder.dart --help
```

### Programmatic Usage
```dart
import 'package:wordclock/generator/backtracking/grid_builder.dart';
import 'package:wordclock/languages/all.dart';

// Create builder
final builder = BacktrackingGridBuilder(
  width: 11,
  height: 10,
  language: englishLanguage,
  seed: 42,
  maxSearchTimeSeconds: 30,      // Timeout
  maxNodesExplored: 500000,      // Node limit
  minCompactnessThreshold: 0.1,  // Quality threshold
);

// Build grid
final grid = builder.build();

if (grid != null) {
  // Success! grid is List<String> with 110 cells
  final wordGrid = WordGrid(width: 11, cells: grid);
  print(wordGrid.toString());
} else {
  print('Failed to find solution');
}
```

### Configuration Parameters

- `width`, `height`: Grid dimensions (typically 11×10)
- `seed`: Random seed for padding character selection
- `maxSearchTimeSeconds`: Maximum search time before giving up (default: 30s)
- `maxNodesExplored`: Maximum nodes to explore (default: 100,000)
- `minCompactnessThreshold`: Minimum overlap ratio to continue search (default: 0.1)
